dataTable<-data.table(read.csv(inputPath))
#  dataTable<-dataTable[order[runif(97)],]
dataTable <- dataTable[,-(57:62),with=FALSE]
set.seed(557)
indataTrain<-createDataPartition(dataTable$y,p=percentOfTrain,list = FALSE)
dataTrain<-dataTable[indataTrain,]
dataTest<-dataTable[-indataTrain,]
dataTrain<-map_df(dataTrain,as.numeric)
tempData<-mRMR.data(data = dataTrain)
ft <- mRMR.classic(data = tempData, target_indices = c(1),
feature_count = numOfFeatures)
index<-as.vector(unlist(ft@filters))
te<-c(1,index)
train_sf <- as.data.table(dataTrain[,te])
test_sf <- dataTest[,te,with=FALSE] ##data.table must set this using colselect
# train_sf<-as.data.table(dataTrain)
# test_sf<-dataTest
train_sf$y<-factor(train_sf$y,levels=c(0,1),labels=c("No", "Yes"))
test_sf$y<-factor(test_sf$y,levels=c(0,1),labels=c("No","Yes"))
#   Modelcontrol<-trainControl(method = "repeatedcv",number = 10,repeats = 1,classProbs =TRUE )
Modelcontrol<-trainControl(method = 'cv',number = 10,allowParallel = TRUE,classProbs = TRUE)
ModelList$rpart$switch<-TRUE
ModelList$pls$switch<-TRUE
#  ModelList$knn$control<-trainControl(method = 'cv',number = 10,classProbs =TRUE,summaryFunction = twoClassSummary,allowParallel = TRUE)
#  ModelList$knn$control<-trainControl(method = 'cv',number = 10,allowParallel = TRUE)
ModelList$knn$parametersGrid<-expand.grid(.k=c(1:20))
ModelList$knn$switch<-TRUE
#  ModelList$nb$control<-trainControl(method = 'cv',number = 10,allowParallel = TRUE)
ModelList$nb$parametersGrid<-expand.grid(fL=c(1:3),usekernel=c(TRUE,FALSE),adjust=c(1:10))
ModelList$nb$switch<-TRUE
ModelList$C5.0$switch<-TRUE
#  ModelList$C5.0$control<-trainControl(method = 'cv',number = 10,allowParallel = TRUE)
ModelList$C5.0$parametersGrid<-expand.grid(trials=c(1:20),model='tree',winnow=FALSE)
ModelList$rf$switch<-TRUE
#  ModelList$rf$control<-trainControl(method = 'cv',number = 10,allowParallel = TRUE)
#  ModelList$rf$control<-
ModelList$rf$parametersGrid<-expand.grid(mtry=c(1:10))
ModelList$svmRadial$switch<-TRUE
ModelList$svmRadial$parametersGrid<-expand.grid(sigma=c(0.27,0.28,0.29),C=c(0.1,0.2,0.3,0.4,0.8,1,1.5,2))
#  ModelList$svmRadial$control<-trainControl(method = 'cv',number = 10,allowParallel = TRUE)
ModelList$nnet$switch<-TRUE
#  ModelList$nnet$control<-trainControl(method = 'cv',number = 10,allowParallel = TRUE)
ModelList$svmLinear$switch<-TRUE
# ModelList$svmLinear$control<-trainControl(method = 'cv',number = 10,allowParallel = TRUE)
coreNum<-detectCores(logical = F)
cl<- makeCluster(coreNum)
registerDoParallel(cl)
system.time({
for(i in c(1:length(ModelList)))
{
if(ModelList[[i]]$switch==TRUE)
{
if(is.null(Modelcontrol))
{
tempTrainCtrl<-trainControl()
}
else
{
tempTrainCtrl<-Modelcontrol
}
if(is.null(ModelList[[i]]$parametersGrid))
{
tempGrid<-NULL;
}
else
{
tempGrid<-ModelList[[i]]$parametersGrid;
}
set.seed(567)
ModelList[[i]]$Model<-train(y~.,data = train_sf,
method=names(ModelList[i]),
trControl=tempTrainCtrl,
tuneGrid=tempGrid,
preProcess = c("center","scale")
)
}
}})
predictors(ModelList$rpart)
predictors(ModelList$C5.0)
ModelList$rpart$Model
ctrl <- gafsControl(functions =rfGA)
obj <- gafs(x = dataTable[,-1],
y = dataTable$y,
# iters = 100,
gafsControl = ctrl
## Now pass options to `train`
)
obj$optVariables
rf_sa$optVariables
lmProfile$optVariables
rfWithFilter$optVariables
install.packages("rattle")
require(rattle)
constructFeaturesList<-function()##construct FeaturesList
{
modelColNames<-c('svmLinearEvlsearch',
'adaboostsearch','rfeldaFuncs',
'rfetreebagFuncs','rferfFuncs','rfenbFuncs',
'ldaSBF','treebagSBF','nbSBF','rfSBF',
'lasso','C5.0','gbm','glmnet','xgbTree','xgbLinear')
modelRowNames<-c('switch','var')
##set the default control and param
control<-list(FALSE,NULL)
names(control)<-modelRowNames
control<-list(control)
ModelList<-rep(control,length(modelColNames))
names(ModelList)<-modelColNames
return(ModelList)
}
hill.climbing.search.svmLinearEvl<-function(inData){
dataTempSf<-inData;
if(!is.factor( inData$y))
dataTempSf$y<-factor(dataTempSf$y,levels=c(0,1),labels=c("NO", "Yes"))
svmLinearEvl<- function(subset) {
#k-fold cross validation
k <- 5
set.seed(globalSeeds)
splits <- runif(nrow(dataTempSf))
results = sapply(1:k, function(i) {
test.idx <- (splits >= (i - 1) / k) & (splits < i / k)
train.idx <- !test.idx
test <- dataTempSf[test.idx, , drop=FALSE]
train <- dataTempSf[train.idx, , drop=FALSE]
tree <- ksvm(as.simple.formula(subset, "y"), train,kernel="vanilladot")
error.rate = sum(test$y != predict(tree, test[,subset])) / nrow(test)
return(1 - error.rate)
})
return(mean(results))
}
set.seed(globalSeeds)
subtmp <- hill.climbing.search(names(dataTempSf[,-1]), svmLinearEvl)
# returnTmpVar<-list(tag=c("svmLinearEvlsearch"),subset=subsets)
return(subtmp)
}
hill.climbing.search.adaboostEvl<-function(inData){
dataTempSf<-inData;
if(!is.factor( inData$y))
dataTempSf$y<-factor(dataTempSf$y,levels=c(0,1),labels=c("NO", "Yes"))
adaboostEvl<- function(subset) {
k <- 5
set.seed(globalSeeds)
splits <- runif(nrow(dataTempSf))
results = sapply(1:k, function(i) {
test.idx <- (splits >= (i - 1) / k) & (splits < i / k)
train.idx <- !test.idx
test <- dataTempSf[test.idx, , drop=FALSE]
train <- dataTempSf[train.idx, , drop=FALSE]
tree <- adaboost(as.simple.formula(subset, "y"), train,10)
tmp<-predict(tree, test[,subset])
##made the two factor level the same
tmp$class <- factor(tmp$class, levels=levels(test$y))
error.rate = sum(test$y != tmp$class) / nrow(test)
return(1 - error.rate)
})
return(mean(results))
}
set.seed(globalSeeds)
subtmp<- hill.climbing.search(names(dataTempSf[,-1]), adaboostEvl)
# returnTmpVar<-list(tag=c("adaboostsearch"),subset=subsets)
return(subtmp)
}
rfeFuncs<-function(inData,funcs,tags)#ldaFuncs,treebagFuncs,rfFuncs,nbFuncs,https://topepo.github.io/caret/recursive-feature-elimination.html
{
dataTempSf<-inData;
if(!is.factor( inData$y))
dataTempSf$y<-factor(dataTempSf$y,levels=c(0,1),labels=c("NO", "Yes"))
set.seed(globalSeeds)
ctrl <- rfeControl(functions = funcs ,
method = "repeatedcv",
repeats = 5
,allowParallel=TRUE
)
tmpModelrfe<- rfe(dataTempSf[,-1], dataTempSf$y,
rfeControl = ctrl)
subtmp<-tmpModelrfe$optVariables
#returnTmpVar<-list(tag=tags,subset=subtmp)
return(subtmp)
}
sbfFuncs<-function(inData,funcs)##ldaSBF,treebagSBF,nbSBF,rfSBF,https://topepo.github.io/caret/feature-selection-using-univariate-filters.html
{
dataTempSf<-inData;
if(!is.factor( inData$y))
dataTempSf$y<-factor(dataTempSf$y,levels=c(0,1),labels=c("NO", "Yes"))
set.seed(globalSeeds)
filterCtrl <- sbfControl( functions = funcs,method = "repeatedcv", repeats = 5)
tmpSbfMOdel <- sbf(x=dataTempSf[,-1], y=dataTempSf$y,sbfControl = filterCtrl)
subtmp<-tmpSbfMOdel$optVariables
# returnTmpVar<-list(tag=tags,subset=subtmp)
return(subtmp)
}
trainModelSf<-function(inData,funcs)#lasso,C5.0,gbm,glmnet,xgbTree,xgbLinear
{
dataTempSf<-inData;
if(!is.factor( inData$y))
dataTempSf$y<-factor(dataTempSf$y,levels=c(0,1),labels=c("NO", "Yes"))
if(funcs %in% c("lasso","ridge"))
dataTempSf$y<-as.numeric(dataTempSf$y)
set.seed(globalSeeds)
tmpModel<-train(y~.,data = dataTempSf,
method=funcs,
trControl=trainControl(method = "repeatedcv",number = 10,repeats = 5 )
)
subtmp<-predictors(tmpModel)
#returnTmpVar<-list(tag=funcs,subset=subtmp)
return(subtmp)
}
connectFeatureListAndFunc<-function(inputDataFrame,functionName)
{
if(functionName %in% c('lasso','C5.0','gbm','glmnet','xgbTree','xgbLinear'))
varTmpVar<-trainModelSf(inputDataFrame,functionName)
if(functionName=='svmLinearEvlsearch')
varTmpVar<-hill.climbing.search.svmLinearEvl(inputDataFrame)
if(functionName=='adaboostsearch')
varTmpVar<-hill.climbing.search.adaboostEvl(inputDataFrame)
if(functionName %in% c('rfeldaFuncs','rfetreebagFuncs','rferfFuncs','rfenbFuncs'))
{
switch(functionName,
'rfeldaFuncs'=varTmpVar<-rfeFuncs(inputDataFrame,ldaFuncs ),
'rfetreebagFuncs'=varTmpVar<-rfeFuncs(inputDataFrame,treebagFuncs),
'rferfFuncs'=varTmpVar<-rfeFuncs(inputDataFrame,rfFuncs),
'rfenbFuncs'=varTmpVar<-rfeFuncs(inputDataFrame,nbFuncs)
)
}
if(functionName %in% c('ldaSBF','treebagSBF','nbSBF','rfSBF'))
{
switch(functionName,
'ldaSBF'=varTmpVar<-sbfFuncs(inputDataFrame,ldaSBF),
'treebagSBF'=varTmpVar<-sbfFuncs(inputDataFrame,treebagSBF),
'nbSBF'=varTmpVar<-sbfFuncs(inputDataFrame,nbSBF),
'rfSBF'=varTmpVar<-sbfFuncs(inputDataFrame,rfSBF)
)
}
return(varTmpVar)
}
fillFeatureList<-function(dealDataFrame)#fill the FeatureList using
{
for(i in 1:length(FeatureList))
{
if(FeatureList[[i]]$switch==TRUE)
{##using try for stepping over error
try(FeatureList[[i]]$var<<-connectFeatureListAndFunc(dealDataFrame,names(FeatureList[i])))
#for closing the wrong way of selection
if(is.null(FeatureList[[i]]$var)) FeatureList[[i]]$switch<-FALSE
}
# foreach(i=1:length(FeatureList),.combine = combine,.errorhandling=c('remove'),.packages = c("caret","FSelector"))
#   %dopar% FeatureList[[i]]$var<<-connectFeatureListAndFunc(dealDataFrame,names(FeatureList[i]))
}
fillFeatureList2<-function(dealDataFrame)#fill the FeatureList using
{
# for(i in 1:length(FeatureList))
# {
#   if(FeatureList[[i]]$switch==TRUE)
#   {##using try for stepping over error
#     try(FeatureList[[i]]$var<<-connectFeatureListAndFunc(dealDataFrame,names(FeatureList[i])))
#     #for closing the wrong way of selection
#     if(is.null(FeatureList[[i]]$var)) FeatureList[[i]]$switch<-FALSE
#   }
# }
foreach(i=1:length(FeatureList),.combine = combine,.errorhandling=c('remove'),.packages = c("caret","FSelector")) %dopar%
FeatureList[[i]]$var<<-connectFeatureListAndFunc(dealDataFrame,names(FeatureList[i]))
}
coreNum<-detectCores(logical = F)
cl<- makeCluster(coreNum)
registerDoParallel(cl)
source("testForPreProcess.R")
loadPackages();
Modelcontrol<-NULL
ModelList<-constructModelList();
FeatureList<-constructFeaturesList()
inputPath<-'txz1.csv'
numOfFeatures<-40
percentOfTrain<-0.8
dataTable<-data.table(read.csv(inputPath))
dataTable<-centerAndScale(dataTable)
dataTable<-implementsRf(dataTable)
set.seed(globalSeeds)
indataTrain<-createDataPartition(dataTable$y,p=percentOfTrain,list = FALSE)
dataTrain<-dataTable[indataTrain,]
dataTest<-dataTable[-indataTrain,]
dataTrain<-map_df(dataTrain,as.numeric)
FeatureList$treebagSBF$switch<-TRUE
FeatureList$nbSBF$switch<-TRUE
FeatureList$rfSBF$switch<-TRUE
coreNum<-detectCores(logical = F)
cl<- makeCluster(coreNum)
registerDoParallel(cl)
sbfFuncs(dataTable,treebagSBF)
?sbf
sbfFuncs<-function(inData,funcs)##ldaSBF,treebagSBF,nbSBF,rfSBF,https://topepo.github.io/caret/feature-selection-using-univariate-filters.html
{
dataTempSf<-inData;
if(!is.factor( inData$y))
dataTempSf$y<-factor(dataTempSf$y,levels=c(0,1),labels=c("NO", "Yes"))
set.seed(globalSeeds)
filterCtrl <- sbfControl( functions = funcs,method = "repeatedcv", repeats = 5)
tmpSbfMOdel <- sbf(form=y~., y=dataTempSf,sbfControl = filterCtrl)
subtmp<-tmpSbfMOdel$optVariables
# returnTmpVar<-list(tag=tags,subset=subtmp)
return(subtmp)
}
sbfFuncs(dataTable,treebagSBF)
sbfFuncs<-function(inData,funcs)##ldaSBF,treebagSBF,nbSBF,rfSBF,https://topepo.github.io/caret/feature-selection-using-univariate-filters.html
{
dataTempSf<-inData;
if(!is.factor( inData$y))
dataTempSf$y<-factor(dataTempSf$y,levels=c(0,1),labels=c("NO", "Yes"))
set.seed(globalSeeds)
filterCtrl <- sbfControl( functions = funcs,method = "repeatedcv", repeats = 5)
tmpSbfMOdel <- sbf(form=y~., data=dataTempSf,sbfControl = filterCtrl)
subtmp<-tmpSbfMOdel$optVariables
# returnTmpVar<-list(tag=tags,subset=subtmp)
return(subtmp)
}
sbfFuncs(dataTable,treebagSBF)
class(dataTable)
debugSource('D:/Git/RSource/Practice1/GlobalVar.R', echo=TRUE)
View(dataTempSf)
tmpSbfMOdel$optVariables
treebagSBF
sbfFuncs(dataTable,treebagSBF)
constructFeaturesList<-function()##construct FeaturesList
{
modelColNames<-c('svmLinearEvlsearch',
'adaboostsearch','rfeldaFuncs',
'rfetreebagFuncs','rferfFuncs','rfenbFuncs',
'ldaSBF','treebagSBF','nbSBF','rfSBF',
'lasso','C5.0','gbm','glmnet','xgbTree','xgbLinear')
modelRowNames<-c('switch','var')
##set the default control and param
control<-list(FALSE,NULL)
names(control)<-modelRowNames
control<-list(control)
ModelList<-rep(control,length(modelColNames))
names(ModelList)<-modelColNames
return(ModelList)
}
hill.climbing.search.svmLinearEvl<-function(inData){
dataTempSf<-inData;
if(!is.factor( inData$y))
dataTempSf$y<-factor(dataTempSf$y,levels=c(0,1),labels=c("NO", "Yes"))
svmLinearEvl<- function(subset) {
#k-fold cross validation
k <- 5
set.seed(globalSeeds)
splits <- runif(nrow(dataTempSf))
results = sapply(1:k, function(i) {
test.idx <- (splits >= (i - 1) / k) & (splits < i / k)
train.idx <- !test.idx
test <- dataTempSf[test.idx, , drop=FALSE]
train <- dataTempSf[train.idx, , drop=FALSE]
tree <- ksvm(as.simple.formula(subset, "y"), train,kernel="vanilladot")
error.rate = sum(test$y != predict(tree, test[,subset])) / nrow(test)
return(1 - error.rate)
})
return(mean(results))
}
set.seed(globalSeeds)
subtmp <- hill.climbing.search(names(dataTempSf[,-1]), svmLinearEvl)
# returnTmpVar<-list(tag=c("svmLinearEvlsearch"),subset=subsets)
return(subtmp)
}
hill.climbing.search.adaboostEvl<-function(inData){
dataTempSf<-inData;
if(!is.factor( inData$y))
dataTempSf$y<-factor(dataTempSf$y,levels=c(0,1),labels=c("NO", "Yes"))
adaboostEvl<- function(subset) {
k <- 5
set.seed(globalSeeds)
splits <- runif(nrow(dataTempSf))
results = sapply(1:k, function(i) {
test.idx <- (splits >= (i - 1) / k) & (splits < i / k)
train.idx <- !test.idx
test <- dataTempSf[test.idx, , drop=FALSE]
train <- dataTempSf[train.idx, , drop=FALSE]
tree <- adaboost(as.simple.formula(subset, "y"), train,10)
tmp<-predict(tree, test[,subset])
##made the two factor level the same
tmp$class <- factor(tmp$class, levels=levels(test$y))
error.rate = sum(test$y != tmp$class) / nrow(test)
return(1 - error.rate)
})
return(mean(results))
}
set.seed(globalSeeds)
subtmp<- hill.climbing.search(names(dataTempSf[,-1]), adaboostEvl)
# returnTmpVar<-list(tag=c("adaboostsearch"),subset=subsets)
return(subtmp)
}
rfeFuncs<-function(inData,funcs,tags)#ldaFuncs,treebagFuncs,rfFuncs,nbFuncs,https://topepo.github.io/caret/recursive-feature-elimination.html
{
dataTempSf<-inData;
if(!is.factor( inData$y))
dataTempSf$y<-factor(dataTempSf$y,levels=c(0,1),labels=c("NO", "Yes"))
set.seed(globalSeeds)
ctrl <- rfeControl(functions = funcs ,
method = "repeatedcv",
repeats = 5
,allowParallel=TRUE
)
tmpModelrfe<- rfe(dataTempSf[,-1], dataTempSf$y,
rfeControl = ctrl)
subtmp<-tmpModelrfe$optVariables
#returnTmpVar<-list(tag=tags,subset=subtmp)
return(subtmp)
}
sbfFuncs<-function(inData,funcs)##ldaSBF,treebagSBF,nbSBF,rfSBF,https://topepo.github.io/caret/feature-selection-using-univariate-filters.html
{
dataTempSf<-inData;
if(!is.factor( inData$y))
dataTempSf$y<-factor(dataTempSf$y,levels=c(0,1),labels=c("NO", "Yes"))
set.seed(globalSeeds)
filterCtrl <- sbfControl( functions = funcs,method = "repeatedcv", repeats = 5)
tmpSbfMOdel <- sbf(form=y~., data=dataTempSf,sbfControl = filterCtrl)
subtmp<-tmpSbfMOdel$optVariables
# returnTmpVar<-list(tag=tags,subset=subtmp)
return(subtmp)
}
trainModelSf<-function(inData,funcs)#lasso,C5.0,gbm,glmnet,xgbTree,xgbLinear
{
dataTempSf<-inData;
if(!is.factor( inData$y))
dataTempSf$y<-factor(dataTempSf$y,levels=c(0,1),labels=c("NO", "Yes"))
if(funcs %in% c("lasso","ridge"))
dataTempSf$y<-as.numeric(dataTempSf$y)
set.seed(globalSeeds)
tmpModel<-train(y~.,data = dataTempSf,
method=funcs,
trControl=trainControl(method = "repeatedcv",number = 10,repeats = 5 )
)
subtmp<-predictors(tmpModel)
#returnTmpVar<-list(tag=funcs,subset=subtmp)
return(subtmp)
}
connectFeatureListAndFunc<-function(inputDataFrame,functionName)
{
if(functionName %in% c('lasso','C5.0','gbm','glmnet','xgbTree','xgbLinear'))
varTmpVar<-trainModelSf(inputDataFrame,functionName)
if(functionName=='svmLinearEvlsearch')
varTmpVar<-hill.climbing.search.svmLinearEvl(inputDataFrame)
if(functionName=='adaboostsearch')
varTmpVar<-hill.climbing.search.adaboostEvl(inputDataFrame)
if(functionName %in% c('rfeldaFuncs','rfetreebagFuncs','rferfFuncs','rfenbFuncs'))
{
switch(functionName,
'rfeldaFuncs'=varTmpVar<-rfeFuncs(inputDataFrame,ldaFuncs ),
'rfetreebagFuncs'=varTmpVar<-rfeFuncs(inputDataFrame,treebagFuncs),
'rferfFuncs'=varTmpVar<-rfeFuncs(inputDataFrame,rfFuncs),
'rfenbFuncs'=varTmpVar<-rfeFuncs(inputDataFrame,nbFuncs)
)
}
if(functionName %in% c('ldaSBF','treebagSBF','nbSBF','rfSBF'))
{
switch(functionName,
'ldaSBF'=varTmpVar<-sbfFuncs(inputDataFrame,ldaSBF),
'treebagSBF'=varTmpVar<-sbfFuncs(inputDataFrame,treebagSBF),
'nbSBF'=varTmpVar<-sbfFuncs(inputDataFrame,nbSBF),
'rfSBF'=varTmpVar<-sbfFuncs(inputDataFrame,rfSBF)
)
}
return(varTmpVar)
}
fillFeatureList<-function(dealDataFrame)#fill the FeatureList using
{
for(i in 1:length(FeatureList))
{
if(FeatureList[[i]]$switch==TRUE)
{##using try for stepping over error
try(FeatureList[[i]]$var<<-connectFeatureListAndFunc(dealDataFrame,names(FeatureList[i])))
#for closing the wrong way of selection
if(is.null(FeatureList[[i]]$var)) FeatureList[[i]]$switch<-FALSE
}
# foreach(i=1:length(FeatureList),.combine = combine,.errorhandling=c('remove'),.packages = c("caret","FSelector"))
#   %dopar% FeatureList[[i]]$var<<-connectFeatureListAndFunc(dealDataFrame,names(FeatureList[i]))
}
fillFeatureList2<-function(dealDataFrame)#fill the FeatureList using
{
# for(i in 1:length(FeatureList))
# {
#   if(FeatureList[[i]]$switch==TRUE)
#   {##using try for stepping over error
#     try(FeatureList[[i]]$var<<-connectFeatureListAndFunc(dealDataFrame,names(FeatureList[i])))
#     #for closing the wrong way of selection
#     if(is.null(FeatureList[[i]]$var)) FeatureList[[i]]$switch<-FALSE
#   }
# }
foreach(i=1:length(FeatureList),.combine = combine,.errorhandling=c('remove'),.packages = c("caret","FSelector")) %dopar%
FeatureList[[i]]$var<<-connectFeatureListAndFunc(dealDataFrame,names(FeatureList[i]))
}
coreNum<-detectCores(logical = F)
cl<- makeCluster(coreNum)
registerDoParallel(cl)
source("testForPreProcess.R")
loadPackages();
Modelcontrol<-NULL
ModelList<-constructModelList();
FeatureList<-constructFeaturesList()
inputPath<-'txz1.csv'
numOfFeatures<-40
percentOfTrain<-0.8
dataTable<-data.table(read.csv(inputPath))
dataTable<-centerAndScale(dataTable)
dataTable<-implementsRf(dataTable)
set.seed(globalSeeds)
indataTrain<-createDataPartition(dataTable$y,p=percentOfTrain,list = FALSE)
dataTrain<-dataTable[indataTrain,]
dataTest<-dataTable[-indataTrain,]
dataTrain<-map_df(dataTrain,as.numeric)
FeatureList$treebagSBF$switch<-TRUE
FeatureList$nbSBF$switch<-TRUE
FeatureList$rfSBF$switch<-TRU
sbfFuncs(dataTable,treebagSBF)
sbfFuncs(dataTable,rfSBF)
